#1. Какой самый эффективный способ конкатенации строк?
	Всего 6 типов конкатенаций:
		1. + - я понял, больше не буду
		2. string.Join()
		3. string.Builder() - лучший, если слов больше 1000

#2. Что такое интерфейсы, как они применяются в Go?
	Интерфейс - это список методов, которыми должен обладать тип, чтобы подходить под интерфейс.
	Нужен для того, чтобы то, что крякает, летает и плавает называть уткой.
	Пустой интерфейс полезен, когда мы не знаем, что закинут в аргумент функции.
	Пустой интерфейс принимает все, а дальше, мы switch a.(type) case int... 
		в зависимости от типа - выбираем действия (полиморфизм)

#3. Чем отличается RWMutex от Mutex?
	Стандартный Mutex блокирует и чтение и запись
	RWMutex есть RLock который блокирует чтение, работает быстрее обычного Mutex
	Если много конкурентного чтения - RWMutex. На чтение можно вызвать множество блокировок RLock()
	Если конкурентной записи - Mutex

#4. Чем отличаются буферизированные и не буферизированные каналы?
	1. Наличием буфера:)
	2. Небуф блокирует горутину после записи, пока кто-то не освободит буфер
		Буф не будет блокироваться, пока есть место в буфере

#5. Какой размер у структуры struct{}{}?
	0
#6. Есть ли в Go перегрузка методов или операторов?
	Нет - во благо ридабилити
#7. В какой последовательности будут выведены элементы map[int]int? 		Пример: m[0]=1 m[1]=124 m[2]=281. В случайном. Мапа - неупорядоченная 		структура данных
#8. В чем разница между make и new?
	make - для слайсов, мап и каналов (Инициализирует) возвращает велью
	new - для всего остального (Обнуляет память) возвращает поинтер

#9 Сколько существует способов задать переменную типа slice или map?
	map := make(map[int]int); a := map[int]int{1:1}
	var slice []int; slice := []int{123}

#10 выведет 1
func update(p *int) { // надо передавать указатель на указатель (p **int)
	b := 2
	p = &b // *p = &b
}
func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p) // update(&p)
	fmt.Println(*p)
}

#11 выведет дедлок
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) { // wg передавать по указателю
			fmt.Println(i)
			wg.Done()
		}(wg, i) // (&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

#12 0. Внутри If создали свою переменную n и ее изменяли.

#13 
func someAction(v []int8, b int8) {
	v[0] = 100 //изменение сработало так как слайс - и так уже ссылка
	v = append(v, b) // а тут создался новый массив, в него все //перезаписалось, добавилось b Но мейновский слайс остался таким же//
	можно менять содержимое массива слайса, но не заголовок слайса (если не по поинтеру передавать)
}
func main() {
	var a = []int8{1, 2, 3, 4, 5} создался слайс с емкостью = длине
	someAction(a, 6)
	fmt.Println(a)
}

#14
func main() {
	slice := []string{"a", "a"}
	func(slice []string) { // анонимная функция приняла заголовок среза по значению
		slice = append(slice, "a") // здесь уже заголовок не равен внешнему, так как пересоздался новый массив
		slice[0] = "b" // изменения копии
		slice[1] = "b" // изменения копии
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
