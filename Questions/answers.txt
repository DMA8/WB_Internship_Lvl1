#1. Какой самый эффективный способ конкатенации строк?
		1. str += str2 - я понял, больше не буду. 
						В 100 раз медленнее, чем стрингБилдер на больших объемах
		2. bytes.Buffer{}; buffer.WriteString(arg) (1.253s)
		3. string.Builder() - Лучший, по мнению гугла, но в моем бенчмарке второй. (1.132s)
		4. copy(). (1.052s) Считаем кол-во новой строки, создаем срез нужной длины, функцией Copy докидываем символы байты
		5. string.Join(args, "") (1.179s)

#2. Что такое интерфейсы, как они применяются в Go?
	Интерфейс - это список методов, которыми должен обладать тип, чтобы подходить под интерфейс.
	Нужен для того, чтобы то, что крякает, летает и плавает называть уткой.
	Пустой интерфейс полезен, когда мы не знаем, что закинут в аргумент функции.
	Пустой интерфейс принимает все, а дальше, мы switch a.(type) case int... 
		в зависимости от типа - выбираем действия (полиморфизм)

#3. Чем отличается RWMutex от Mutex?
	Стандартный Mutex блокирует и чтение и запись (Lock ~70ns Unlock ~50ns)
	RWMutex есть RLock который блокирует чтение, работает быстрее обычного Mutex 
	Если много конкурентного чтения - RWMutex. На чтение можно вызвать множество блокировок RLock() (Rlock + Unlock 13 ns) НО на запись Lock-Unluck 300 ns
	Хороший пример - чтение из кеша (map): Делаем Rlock перед чтением и пока мы не сделали RUnlock другие горутины не могут сделаь Lock (на запись). Но RLock доступен
	Если конкурентной записи - Mutex (Lock + Unclo)

#4. Чем отличаются буферизированные и не буферизированные каналы?
	1. Наличием буфера:)
	2. Небуф блокирует горутину после записи, пока кто-то не освободит буфер
		Буф не будет блокироваться, пока есть место в буфере

#5. Какой размер у структуры struct{}{}?
	0
#6. Есть ли в Go перегрузка методов или операторов?
	Нет - во благо ридабилити
#7. В какой последовательности будут выведены элементы map[int]int? 		Пример: m[0]=1 m[1]=124 m[2]=281. В случайном. Мапа - неупорядоченная структура данных
#8. В чем разница между make и new?
	make - для слайсов, мап и каналов (Инициализирует) возвращает указатель на мапу, слайс или канал. (Эти типы содержат ссылку на что-то, если их пихнуть в new() то получим nil как адрес)
	new - для всего остального (Обнуляет память) возвращает указатель на объект с нулевыми значениями

#9 Сколько существует способов задать переменную типа slice или map?
	map := make(map[int]int); a := map[int]int{1:1}
	var slice []int; slice := []int{123}

#10 выведет 1
func update(p *int) { // надо передавать указатель на указатель (p **int)
	b := 2
	p = &b // *p = &b
}
func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p) // update(&p)
	fmt.Println(*p)
}

#11 выведет дедлок
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) { // wg передавать по указателю
			fmt.Println(i)
			wg.Done()
		}(wg, i) // (&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

#12 0. Внутри If создали свою переменную n и ее изменяли.

#13 
func someAction(v []int8, b int8) {
	v[0] = 100 //изменение сработало так как слайс - и так уже ссылка
	v = append(v, b) // а тут создался новый массив, в него все //перезаписалось, добавилось b Но мейновский слайс остался таким же//
	можно менять содержимое массива слайса, но не заголовок слайса (если не по поинтеру передавать)
}
func main() {
	var a = []int8{1, 2, 3, 4, 5} создался слайс с емкостью = длине
	someAction(a, 6)
	fmt.Println(a)
}

#14
func main() {
	slice := []string{"a", "a"}
	func(slice []string) { // анонимная функция приняла заголовок среза по значению
		slice = append(slice, "a") // здесь уже заголовок слайса не равен внешнему, так как пересоздался новый массив
		slice[0] = "b" // изменение элемента в новом массиве, который был создан строкой выше
		slice[1] = "b" // изменения копии
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
